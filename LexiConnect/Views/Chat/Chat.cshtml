@model LexiConnect.Models.ChatModel
@{
    ViewData["Title"] = "Chat";
    Layout = "_Layout";
}
<head>
    <link rel="stylesheet" href="~/css/Chat/Chat.css" />
</head>
<div class="container">
    <div class="main-content">
        <!-- Sidebar -->
        <div class="sidebar">
            <h2 class="sidebar-title">
                <svg class="icon" fill="currentColor" viewBox="0 0 20 20">
                    <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z"></path>
                    <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z"></path>
                </svg>
                Previous Chats
            </h2>
            <div class="sidebar-content">
                <ul id="chatUsersList" class="chat-users-list">
                    @if (Model.ChatUsers.Any())
                    {
                        @foreach (var chatUser in Model.ChatUsers)
                        {
                            <li>
                                <button class="user-item @(Model.CurrentReceiver?.Id == chatUser.UserId ? "selected" : "")"
                                        onclick="selectUser('@chatUser.UserId', '@chatUser.UserName', '@Url.Content(chatUser.UserAvatar ?? "/image/default-avatar.png")')">
                                    <div class="user-avatar-container">
                                        <div class="avatar">
                                            <img src="@Url.Content(chatUser.UserAvatar ?? "/image/default-avatar.png")" alt="@chatUser.UserName" />
                                        </div>
                                        <div class="online-indicator hidden" data-user-id="@chatUser.UserId"></div>
                                    </div>
                                    <div class="user-info">
                                        <div class="user-header">
                                            <div class="user-name">@chatUser.UserName</div>
                                            <div class="message-time">@chatUser.LastMessageTime.ToString("MM/dd HH:mm")</div>
                                        </div>
                                        <div class="last-message">@chatUser.LastMessage</div>
                                        <div class="message-meta">
                                            @if (chatUser.MessageCount > 0)
                                            {
                                                <div class="badge badge-neutral badge-sm">@chatUser.MessageCount</div>
                                            }
                                        </div>
                                    </div>
                                </button>
                            </li>
                        }
                    }
                    else
                    {
                        <li class="no-chats-message">No previous chats found</li>
                    }
                </ul>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area">
            <!-- Header -->
            <div id="chatHeader" class="chat-header">
                <div class="chat-header-content">
                    <div class="avatar avatar-sm">
                        <img id="receiverAvatar"
                             src="@Url.Content(Model.CurrentReceiver?.AvatarUrl ?? "/image/default-avatar.png")"
                             alt="Receiver Avatar" />
                    </div>
                    <span id="receiverName" class="receiver-name">
                        @if (Model.CurrentReceiver != null)
                        {
                            @Model.CurrentReceiver.UserName
                        }
                        else
                        {
                            @:Select a chat to start messaging
                        }
                    </span>
                </div>
            </div>

            <!-- Messages -->
            <div class="messages-container" id="messagesContainer">
                @if (Model.CurrentReceiver != null && Model.ChatHistory.Any())
                {
                    @foreach (var message in Model.ChatHistory)
                    {
                        var isReceived = message.SenderId != Model.CurrentUser.Id;
                        var messageTime = message.Timestamp.ToString("HH:mm");
                        <div class="chat @(isReceived ? "chat-start" : "chat-end")">
                            <div class="chat-image avatar">
                                <img src="@Url.Content(isReceived
                                                                         ? (Model.CurrentReceiver.AvatarUrl ?? "/image/default-avatar.png")
                                                                         : (Model.CurrentUser.AvatarUrl ?? "/image/default-avatar.png"))"
                             alt="@(isReceived? Model.CurrentReceiver.UserName : Model.CurrentUser.UserName)" />
                    </div>
                    <div class="chat-header">
                        @(isReceived? Model.CurrentReceiver.UserName : Model.CurrentUser.UserName)
                        <time class="message-timestamp">@messageTime</time>
                    </div>
                    <div class="chat-bubble @(isReceived ? "chat-bubble-primary" : "chat-bubble-secondary")">
                        @message.Message
                    </div>
                </div>
                                }
                }
                else if (Model.CurrentReceiver != null)
                {
                    <div class="empty-state">
                        <div class="chat chat-start">
                            <div class="chat-bubble chat-bubble-info">
                                Start your conversation with @Model.CurrentReceiver.UserName
                            </div>
                        </div>
                    </div>
                }
                else
                {
                    <div class="empty-state">
                        <div class="chat chat-start">
                            <div class="chat-bubble chat-bubble-info">
                                Welcome to the chat! Select a conversation from the sidebar to start messaging.
                            </div>
                        </div>
                    </div>
                }
            </div>

            <!-- Input -->
            <div class="message-input-container">
                @Html.AntiForgeryToken()
                <form id="messageForm" class="message-form">
                    <input type="text" id="messageInput" placeholder="Type your message..."
                           class="input" maxlength="500"
                           @(Model.CurrentReceiver == null ? "disabled" : "") />
                    <button type="submit" id="sendButton" class="btn btn-primary"
                            @(Model.CurrentReceiver == null ? "disabled" : "")>
                        <svg class="icon" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.429a1 1 0 001.17-1.409l-7-14z"></path>
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Loading + Toast -->
<div id="loadingOverlay" class="loading-overlay hidden">
    <div class="loading loading-spinner loading-lg"></div>
</div>
<div class="toast" id="toastContainer"></div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.7/signalr.min.js"></script>
    <script>
        let connection;
        let currentReceiverId = @Html.Raw(Model.CurrentReceiver?.Id != null ? $"'{Model.CurrentReceiver.Id}'" : "null");
        let currentUserId = '@Html.Raw(Model.CurrentUser?.Id)';
        let connectedUsers = [];

        // Store resolved URLs from Razor
        const defaultAvatarUrl = '@Url.Content("/image/default-avatar.png")';
        const currentUserAvatar = '@Url.Content(Model.CurrentUser?.AvatarUrl ?? "/image/default-avatar.png")';
        const currentReceiverAvatar = '@Url.Content(Model.CurrentReceiver?.AvatarUrl ?? "/image/default-avatar.png")';
        const currentUserName = '@Html.Raw(Model.CurrentUser?.UserName ?? "You")';

        // Initialize SignalR connection
        async function initializeConnection() {
            try {
                connection = new signalR.HubConnectionBuilder()
                    .withUrl("/ChatHub")
                    .withAutomaticReconnect([0, 2000, 10000, 30000])
                    .build();

                // Handle updated connected users
                connection.on("UpdatedConnectedUsers", function (users) {
                    console.log('Updated connected users:', users);
                    connectedUsers = users;
                    updateOnlineStatus(users);
                });

                // Handle received messages
                connection.on("ReceiveMessage", function (senderId, senderName, message, timestamp) {
                    console.log('Received message:', { senderId, senderName, message, timestamp });
                    if (senderId === currentReceiverId || senderId === currentUserId) {
                        displayMessage(senderId, senderName, message, timestamp, senderId !== currentUserId);
                        scrollToBottom();
                        updateSidebarLastMessage(senderId === currentUserId ? currentReceiverId : senderId, message, timestamp);
                    }
                });

                // Handle message sent confirmation
                connection.on("MessageSent", function (receiverId, message, timestamp) {
                    console.log('Message sent confirmation:', { receiverId, message, timestamp });
                });

                // Handle errors
                connection.on("Error", function (errorMessage) {
                    console.error('SignalR Error:', errorMessage);
                    showToast('Error: ' + errorMessage, "error");
                });

                // Handle typing indicators
                connection.on("UserTyping", function (userId, userName, isTyping) {
                    if (userId === currentReceiverId && isTyping) {
                        showTypingIndicator(userName);
                    } else {
                        hideTypingIndicator();
                    }
                });

                await connection.start();
                console.log('SignalR connected successfully');
                showToast("Connected to chat server", "success");

                // Monitor connection state
                monitorConnectionState();

                if (currentReceiverId) {
                    scrollToBottom();
                }
            } catch (err) {
                console.error('SignalR connection error:', err);
                showToast('Failed to connect to chat server: ' + err.message, "error");
            }
        }

        // Monitor connection state
        function monitorConnectionState() {
            if (connection) {
                connection.onclose((error) => {
                    console.log('Connection closed:', error);
                    showToast("Connection lost. Attempting to reconnect...", "warning");

                    setTimeout(async () => {
                        try {
                            await connection.start();
                            showToast("Reconnected to chat server", "success");
                        } catch (err) {
                            console.error('Reconnection failed:', err);
                            showToast("Failed to reconnect. Please refresh the page.", "error");
                        }
                    }, 3000);
                });

                connection.onreconnecting((error) => {
                    console.log('Reconnecting:', error);
                    showToast("Reconnecting to chat server...", "info");
                });

                connection.onreconnected((connectionId) => {
                    console.log('Reconnected:', connectionId);
                    showToast("Reconnected to chat server", "success");
                });
            }
        }

        // Send message function
        async function sendMessage() {
            console.log('sendMessage called, currentReceiverId:', currentReceiverId);
            console.log('connection state:', connection ? connection.state : 'no connection');

            const messageInput = document.getElementById('messageInput');
            const message = messageInput.value.trim();

            if (!message) {
                console.log('No message to send');
                return;
            }

            if (!currentReceiverId) {
                console.log('No receiver selected');
                showToast("Please select a user to chat with", "error");
                return;
            }

            if (!connection) {
                console.log('No SignalR connection');
                showToast("Not connected to chat server", "error");
                return;
            }

            if (connection.state !== signalR.HubConnectionState.Connected) {
                console.log('SignalR not connected, state:', connection.state);
                showToast("Connection lost. Trying to reconnect...", "warning");
                try {
                    await connection.start();
                } catch (error) {
                    console.error('Failed to reconnect:', error);
                    showToast("Failed to reconnect to chat server", "error");
                    return;
                }
            }

            try {
                console.log('Sending message via SignalR...', { receiverId: currentReceiverId, message });

                // Clear input immediately to prevent double sending
                messageInput.value = '';

                // Send message via SignalR
                await connection.invoke("SendMessage", currentReceiverId, message);
                console.log('Message sent successfully');

                // Display message locally immediately
                displayMessage(currentUserId, currentUserName, message, new Date().toISOString(), false);
                scrollToBottom();

                // Update sidebar
                updateSidebarLastMessage(currentReceiverId, message, new Date().toISOString());

            } catch (error) {
                console.error('Error sending message:', error);
                showToast('Failed to send message: ' + (error.message || error), "error");

                // Restore message in input if failed
                messageInput.value = message;
            }
        }

        // Update online status indicators
        function updateOnlineStatus(users) {
            document.querySelectorAll('.online-indicator').forEach(indicator => {
                indicator.classList.add('hidden');
            });

            users.forEach(user => {
                const indicator = document.querySelector('[data-user-id="' + user.userId + '"]');
                if (indicator) {
                    indicator.classList.remove('hidden');
                }
            });
        }

        // Update sidebar last message
        function updateSidebarLastMessage(userId, message, timestamp) {
            const userButton = document.querySelector('button[onclick*="' + userId + '"]');
            if (userButton) {
                const messageElement = userButton.querySelector('.last-message');
                const timeElement = userButton.querySelector('.message-time');

                if (messageElement) {
                    messageElement.textContent = message.length > 30 ? message.substring(0, 30) + '...' : message;
                }

                if (timeElement) {
                    const time = new Date(timestamp);
                    timeElement.textContent = time.toLocaleString('en-US', {
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    }).replace(',', '');
                }

                const listItem = userButton.closest('li');
                const list = document.getElementById('chatUsersList');
                if (listItem && list) {
                    list.insertBefore(listItem, list.firstChild);
                }
            }
        }

        // Highlight selected user
        function highlightSelectedUser(userId) {
            document.querySelectorAll('.user-item').forEach(item => {
                item.classList.remove('selected');
            });

            const selectedButton = document.querySelector('button[onclick*="' + userId + '"]');
            if (selectedButton) {
                selectedButton.classList.add('selected');
            }
        }

        // Select user to chat with
        async function selectUser(userId, userName, userAvatar) {
            const newUrl = '/Chat/Chat/' + userId;
            //Updates URL history
            window.history.pushState({}, '', newUrl);

            //Sets currentReceiverId
            currentReceiverId = userId;

            //Updates UI elements (header, avatar, name)
            document.getElementById('receiverName').textContent = userName;
            document.getElementById('receiverAvatar').src = userAvatar || defaultAvatarUrl;
            document.getElementById('messageInput').disabled = false;
            document.getElementById('sendButton').disabled = false;

            highlightSelectedUser(userId);

            //Clears message container
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '';

            await loadChatHistoryAjax(userId);

            document.getElementById('messageInput').focus();

            showToast('Opened chat with ' + userName, "success");
        }

        // Load chat history via AJAX
        async function loadChatHistoryAjax(receiverId) {
            try {
                const response = await fetch('/Chat/Chat/ChatHistory?receiverId=' + receiverId, {
                    method: 'GET',
                    headers: {
                        'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value
                    }
                });

                if (response.ok) {
                    const chatHistory = await response.json();
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';

                    chatHistory.forEach(message => {
                        displayMessage(
                            message.senderId,
                            message.senderName,
                            message.message,
                            message.timestamp,
                            message.senderId !== currentUserId
                        );
                    });

                    scrollToBottom();
                } else {
                    console.error('Failed to load chat history');
                    showToast("Failed to load chat history", "error");
                }
            } catch (error) {
                console.error('Error loading chat history:', error);
                showToast("Error loading chat history", "error");
            }
        }


        // Display message in chat
        function displayMessage(senderId, senderName, message, timestamp, isReceived) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageTime = new Date(timestamp).toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit'
            });

            const messageElement = document.createElement('div');
            messageElement.className = 'chat ' + (isReceived ? 'chat-start' : 'chat-end');

            messageElement.innerHTML =
                '<div class="chat-image avatar">' +
                '<img src="' + getCurrentUserAvatar(senderId) + '" alt="' + escapeHtml(senderName) + '" />' +
                '</div>' +
                '<div class="chat-header">' +
                escapeHtml(senderName) +
                '<time class="message-timestamp">' + messageTime + '</time>' +
                '</div>' +
                '<div class="chat-bubble ' + (isReceived ? 'chat-bubble-primary' : 'chat-bubble-secondary') + '">' +
                escapeHtml(message) +
                '</div>';

            messagesContainer.appendChild(messageElement);
        }

        // Get current user avatar helper
        function getCurrentUserAvatar(senderId) {
            if (senderId === currentUserId) {
                return currentUserAvatar;
            }

            const user = connectedUsers.find(u => u.userId === senderId);
            return user ? (user.userAvatar || defaultAvatarUrl) : currentReceiverAvatar;
        }

        // Utility functions
        function scrollToBottom() {
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showToast(message, type) {
            type = type || 'info';
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'alert alert-' + type;
            toast.innerHTML = '<div><span>' + escapeHtml(message) + '</span></div>';

            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function showLoadingOverlay(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (show) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        }

        function showTypingIndicator(userName) {
            const messagesContainer = document.getElementById('messagesContainer');
            const existingIndicator = document.getElementById('typingIndicator');

            if (!existingIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'typingIndicator';
                indicator.className = 'chat chat-start';
                indicator.innerHTML =
                    '<div class="chat-bubble chat-bubble-primary typing-indicator">' +
                    '<span class="loading loading-dots loading-sm"></span>' +
                    escapeHtml(userName) + ' is typing...' +
                    '</div>';
                messagesContainer.appendChild(indicator);
                scrollToBottom();
            }
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {
            // Send button click handler
            const sendButton = document.getElementById('sendButton');
            if (sendButton) {
                sendButton.addEventListener('click', function (e) {
                    e.preventDefault();
                    sendMessage();
                });
            }

            // Form submission handler
            const messageForm = document.getElementById('messageForm');
            if (messageForm) {
                messageForm.addEventListener('submit', function (e) {
                    e.preventDefault();
                    sendMessage();
                });
            }

            // Message input Enter key handler
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });

                // Typing detection
                let typingTimer;
                messageInput.addEventListener('input', function () {
                    if (currentReceiverId && connection && connection.state === signalR.HubConnectionState.Connected) {
                        connection.invoke("UserTyping", currentReceiverId, true).catch(err => {
                            console.error('Error sending typing indicator:', err);
                        });

                        clearTimeout(typingTimer);
                        typingTimer = setTimeout(() => {
                            if (connection && connection.state === signalR.HubConnectionState.Connected) {
                                connection.invoke("UserTyping", currentReceiverId, false).catch(err => {
                                    console.error('Error sending typing indicator:', err);
                                });
                            }
                        }, 1000);
                    }
                });
            }

            // Initialize connection
            initializeConnection();

            console.log('Event listeners initialized');
        });

        // Handle browser navigation
        window.addEventListener('popstate', function (event) {
            const pathParts = window.location.pathname.split('/');
            const receiverId = pathParts[pathParts.length - 1];

            if (receiverId && receiverId !== 'Chat' && receiverId !== currentReceiverId) {
                window.location.reload();
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', function () {
            if (connection) {
                connection.stop();
            }
        });

        // Make functions globally accessible for onclick handlers
        window.sendMessage = sendMessage;
        window.selectUser = selectUser;
    </script>
}